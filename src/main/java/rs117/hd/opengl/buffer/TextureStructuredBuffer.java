package rs117.hd.opengl.buffer;

import java.nio.ByteBuffer;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL11.glBindTexture;
import static org.lwjgl.opengl.GL11.glDeleteTextures;
import static org.lwjgl.opengl.GL11.glGenTextures;
import static org.lwjgl.opengl.GL13.glActiveTexture;
import static org.lwjgl.opengl.GL15.GL_DYNAMIC_DRAW;
import static org.lwjgl.opengl.GL15.glBindBuffer;
import static org.lwjgl.opengl.GL15.glBufferData;
import static org.lwjgl.opengl.GL15C.glBufferSubData;
import static org.lwjgl.opengl.GL30.GL_R32I;
import static org.lwjgl.opengl.GL31.GL_TEXTURE_BUFFER;
import static org.lwjgl.opengl.GL31.glTexBuffer;
import static rs117.hd.HdPlugin.TEXTURE_UNIT_UNUSED;

@Slf4j
public class TextureStructuredBuffer extends StructuredBuffer<GLBuffer> {
	private int textureId;
	private int currentCapacity;

	public TextureStructuredBuffer() {
		super(GL_TEXTURE_BUFFER, GL_DYNAMIC_DRAW);
		this.currentCapacity = 0;
		this.alignStructs = false;
	}

	public void initialize(int bindingIndex) {
		super.initialize();
		bind(bindingIndex);

		// Create the texture buffer
		textureId = glGenTextures();
		glActiveTexture(bindingIndex);
		glBindTexture(GL_TEXTURE_BUFFER, textureId);
		glTexBuffer(GL_TEXTURE_BUFFER, GL_R32I, glBuffer.id);
		glActiveTexture(TEXTURE_UNIT_UNUSED);
		glBindTexture(GL_TEXTURE_BUFFER, 0);
		currentCapacity = size;
	}

	@Override
	protected boolean preUpload() {
		if (size > currentCapacity) {
			int newSize = size * 2;
			log.info("{} resizing from {} -> {}", glBuffer.name, currentCapacity, newSize);

			ByteBuffer newData = BufferUtils.createByteBuffer(newSize);
			if (data != null) {
				data.position(0);
				newData.put(data);
				newData.flip();
			}

			glBindBuffer(glBuffer.target, glBuffer.id);
			glBufferData(glBuffer.target, newSize, GL_DYNAMIC_DRAW);
			glBufferSubData(glBuffer.target, 0, newData);
			glBindBuffer(glBuffer.target, 0);

			glBindTexture(GL_TEXTURE_BUFFER, textureId);
			glTexBuffer(GL_TEXTURE_BUFFER, GL_R32I, glBuffer.id);
			glBindTexture(GL_TEXTURE_BUFFER, 0);

			newData.limit(newSize);
			data = newData;
			dataInt = data.asIntBuffer();
			dataFloat = data.asFloatBuffer();

			currentCapacity = newSize;

			// Reset Tide, since we've uploaded the data as part of the resize
			dirtyLowTide = Integer.MAX_VALUE;
			dirtyHighTide = 0;
			return false;
		}

		return true;
	}

	public String generateGetter(String structName, String functionName) {
		StructDefinition def = getStructDefinition(structName);
		if(def == null) {
			return "";
		}

		StringBuilder sb = new StringBuilder();
		sb.append("/// Auto-generated by TextureStructuredBuffer\n");
		sb.append(structName).append(" ").append(functionName).append("(int index, isamplerBuffer sampler) {\n");
		sb.append("    ").append(structName).append(" s;\n");

		int texelIndex = 0;
		for (Property prop : def.properties) {
			String glslType;
			switch (prop.type) {
				case Int:   glslType = "int"; break;
				case IVec2: glslType = "ivec2"; break;
				case IVec3: glslType = "ivec3"; break;
				case IVec4: glslType = "ivec4"; break;
				case Float: glslType = "float"; break;
				case FVec2: glslType = "vec2"; break;
				case FVec3: glslType = "vec3"; break;
				case FVec4: glslType = "vec4"; break;
				case Mat3:  glslType = "mat3"; break;
				case Mat4:  glslType = "mat4"; break;
				default: glslType = "uint"; break;
			}

			int texelCount = prop.type.size / 4;
			sb.append("    s.").append(prop.name).append(" = ");
			if (texelCount == 1) {
				sb.append(glslType.equals("float") ?
						"intBitsToFloat(texelFetch(" : "texelFetch(sampler, index + ").append(texelIndex).append(").r");
				if (glslType.equals("float"))
					sb.append(")");
			} else {
				sb.append(glslType).append("(");
				for (int i = 0; i < texelCount; i++) {
					if (i > 0) sb.append(", ");
					sb.append("texelFetch(sampler, index + ").append(texelIndex + i).append(").r");
				}
				sb.append(")");
			}
			sb.append(";\n");
			texelIndex += texelCount;
		}

		sb.append("    return s;\n");
		sb.append("}\n");
		return sb.toString();
	}

	@Override
	public void destroy() {
		super.destroy();

		if (textureId != 0) {
			glDeleteTextures(textureId);
			textureId = 0;
		}

		currentCapacity = 0;
	}
}

