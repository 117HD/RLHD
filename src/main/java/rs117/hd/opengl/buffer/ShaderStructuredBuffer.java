package rs117.hd.opengl.buffer;

import java.nio.ByteBuffer;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.opengl.GLBinding;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL11.glBindTexture;
import static org.lwjgl.opengl.GL11.glDeleteTextures;
import static org.lwjgl.opengl.GL11.glGenTextures;
import static org.lwjgl.opengl.GL15.GL_DYNAMIC_DRAW;
import static org.lwjgl.opengl.GL15.glBindBuffer;
import static org.lwjgl.opengl.GL15.glBufferData;
import static org.lwjgl.opengl.GL30.GL_R32I;
import static org.lwjgl.opengl.GL30.glBindBufferBase;
import static org.lwjgl.opengl.GL31.GL_TEXTURE_BUFFER;
import static org.lwjgl.opengl.GL31.glTexBuffer;
import static org.lwjgl.opengl.GL43.GL_SHADER_STORAGE_BUFFER;
import static rs117.hd.HdPlugin.GL_CAPS;
import static rs117.hd.HdPlugin.checkGLErrors;

@Slf4j
public class ShaderStructuredBuffer extends StructuredBuffer<GLBuffer> {
	private final boolean isTextureBuffer;
	private int textureBufferId;
	private int currentCapacity;

	public ShaderStructuredBuffer() {
		super(GL_CAPS.GL_ARB_texture_buffer_object ? GL_SHADER_STORAGE_BUFFER : GL_TEXTURE_BUFFER, GL_DYNAMIC_DRAW);
		this.isTextureBuffer = !GL_CAPS.GL_ARB_texture_buffer_object;
		this.currentCapacity = 0;
		this.alignment = !isTextureBuffer;
	}

	public void initialize(GLBinding binding) {
		super.initialize();
		this.binding = binding;
		if (isTextureBuffer) {
			textureBufferId = glGenTextures();
			binding.setActive();
			glBindTexture(GL_TEXTURE_BUFFER, textureBufferId);
			glTexBuffer(GL_TEXTURE_BUFFER, GL_R32I, glBuffer.id);

			GLBinding.BINDING_NONE.setActive();
			glBindTexture(GL_TEXTURE_BUFFER, 0);
		} else {
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding.getBufferBindingIndex(), glBuffer.id);
		}

		currentCapacity = size;
		checkGLErrors();
	}

	@Override
	protected boolean preUpload() {
		if (size > currentCapacity) {
			int newSize = size * 2;
			log.info("{} resizing from {} -> {}", glBuffer.name, currentCapacity, newSize);

			ByteBuffer newData = BufferUtils.createByteBuffer(newSize);
			if (data != null) {
				data.position(0);
				newData.put(data);
				newData.clear();
			}

			glBindBuffer(glBuffer.target, glBuffer.id);
			glBufferData(glBuffer.target, newData, GL_DYNAMIC_DRAW);
			glBindBuffer(glBuffer.target, 0);
			glBuffer.size = newSize;

			if (isTextureBuffer) {
				glBindTexture(GL_TEXTURE_BUFFER, textureBufferId);
				glTexBuffer(GL_TEXTURE_BUFFER, GL_R32I, glBuffer.id);
				glBindTexture(GL_TEXTURE_BUFFER, 0);
			}

			data = newData;
			dataInt = data.asIntBuffer();
			dataFloat = data.asFloatBuffer();

			currentCapacity = newSize;
			return false;
		}

		return true;
	}

	public String generateGetter(String structName, String functionName) {
		StructDefinition def = getStructDefinition(structName);
		if (def == null)
			return "";

		StringBuilder sb = new StringBuilder();
		sb.append("/// Auto-generated by ShaderStructuredBuffer\n");

		if (isTextureBuffer) {
			// Texture buffer path (TBO)
			sb.append("uniform isamplerBuffer ")
				.append(structName.toLowerCase())
				.append("Sampler;\n\n");

			sb.append(structName)
				.append(" ")
				.append(functionName)
				.append("(int index) {\n")
				.append("    ")
				.append(structName)
				.append(" s;\n")
				.append("    index *= ")
				.append(def.sizeBytes / 4)
				.append(";\n");

			int texelIndex = 0;
			for (Property prop : def.properties) {
				String glslType;
				switch (prop.type) {
					case Int:   glslType = "int"; break;
					case IVec2: glslType = "ivec2"; break;
					case IVec3: glslType = "ivec3"; break;
					case IVec4: glslType = "ivec4"; break;
					case Float: glslType = "float"; break;
					case FVec2: glslType = "vec2"; break;
					case FVec3: glslType = "vec3"; break;
					case FVec4: glslType = "vec4"; break;
					case Mat3:  glslType = "mat3"; break;
					case Mat4:  glslType = "mat4"; break;
					default:    glslType = "uint"; break;
				}

				int texelCount = prop.type.size / 4;
				sb.append("    s.").append(prop.name).append(" = ");

				if (texelCount == 1) {
					sb.append(glslType.equals("float")
						? "intBitsToFloat(texelFetch(" + structName.toLowerCase() + "Sampler, index + " + texelIndex + ").r)"
						: "texelFetch(" + structName.toLowerCase() + "Sampler, index + " + texelIndex + ").r");
				} else {
					sb.append(glslType).append("(");
					for (int i = 0; i < texelCount; i++) {
						if (i > 0) sb.append(", ");
						sb.append("texelFetch(")
							.append(structName.toLowerCase())
							.append("Sampler, index + ")
							.append(texelIndex + i)
							.append(").r");
					}
					sb.append(")");
				}
				sb.append(";\n");
				texelIndex += texelCount;
			}

			sb.append("    return s;\n}\n");
		} else {
			// SSBO path
			sb.append("layout(std430, binding = ")
				.append(binding.getBufferBindingIndex())
				.append(") buffer ")
				.append(structName)
				.append("Buffer { ")
				.append(structName)
				.append(" data[]; };\n\n");

			sb.append(structName)
				.append(" ")
				.append(functionName)
				.append("(int index) {\n")
				.append("    return data[index];\n")
				.append("}\n");
		}

		return sb.toString();
	}

	@Override
	public void destroy() {
		super.destroy();

		if (textureBufferId != 0)
			glDeleteTextures(textureBufferId);

		textureBufferId = 0;
		currentCapacity = 0;
	}
}
