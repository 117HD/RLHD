package rs117.hd.opengl.buffer;

import java.nio.ByteBuffer;
import lombok.extern.slf4j.Slf4j;
import org.lwjgl.BufferUtils;
import rs117.hd.HdPlugin;
import rs117.hd.opengl.GLBinding;
import rs117.hd.utils.buffer.GLBuffer;

import static org.lwjgl.opengl.GL33C.*;
import static org.lwjgl.opengl.GL43.GL_SHADER_STORAGE_BUFFER;
import static rs117.hd.HdPlugin.checkGLErrors;

@Slf4j
public class ShaderStructuredBuffer extends StructuredBuffer<GLBuffer> {
	private static final boolean FORCE_TEXTURE_BUFFER = false;

	private static final int TEXEL_INT_COMPONENTS = 3;

	private final boolean isTextureBuffer;
	private int textureBufferId;
	private int currentCapacity;

	public static boolean supportsShaderStorage() {
		if (FORCE_TEXTURE_BUFFER) return false;
		return HdPlugin.GL_CAPS.GL_ARB_shader_storage_buffer_object;
	}

	public ShaderStructuredBuffer() {
		super(supportsShaderStorage() ? GL_SHADER_STORAGE_BUFFER : GL_TEXTURE_BUFFER, GL_DYNAMIC_DRAW);
		this.isTextureBuffer = !supportsShaderStorage();
		this.currentCapacity = 0;
		this.alignment = !isTextureBuffer;
	}

	public void initialize(GLBinding binding) {
		super.initialize();
		this.binding = binding;
		if (isTextureBuffer) {
			textureBufferId = glGenTextures();
			binding.setActive();
			glBindTexture(GL_TEXTURE_BUFFER, textureBufferId);
			glTexBuffer(GL_TEXTURE_BUFFER, GL_RGB32I, glBuffer.id);

			checkGLErrors(() -> String.format("%s.glTexBuffer()", glBuffer.name));

			GLBinding.BINDING_NONE.setActive();
			glBindTexture(GL_TEXTURE_BUFFER, 0);
		} else {
			glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding.getBufferBindingIndex(), glBuffer.id);
			checkGLErrors(() -> String.format("%s.glBindBufferBase(%d)", glBuffer.name, binding.getBufferBindingIndex()));
		}

		currentCapacity = size;
		checkGLErrors();
	}

	@Override
	protected boolean preUpload() {
		if (size > currentCapacity) {
			int newSize = size * 2;
			log.info("{} resizing from {} -> {}", glBuffer.name, currentCapacity, newSize);

			ByteBuffer newData = BufferUtils.createByteBuffer(newSize);
			if (data != null) {
				data.position(0);
				newData.put(data);
				newData.clear();
			}

			glBindBuffer(glBuffer.target, glBuffer.id);
			glBufferData(glBuffer.target, newData, GL_DYNAMIC_DRAW);
			glBindBuffer(glBuffer.target, 0);
			glBuffer.size = newSize;

			checkGLErrors(() -> String.format("%s.glBufferData(%d)", glBuffer.name, newSize));

			if (isTextureBuffer) {
				glBindTexture(GL_TEXTURE_BUFFER, textureBufferId);
				glTexBuffer(GL_TEXTURE_BUFFER, GL_RGB32I, glBuffer.id);
				glBindTexture(GL_TEXTURE_BUFFER, 0);

				checkGLErrors(() -> String.format("%s.glTexBuffer()", glBuffer.name));
			}

			data = newData;
			dataInt = data.asIntBuffer();
			dataFloat = data.asFloatBuffer();

			currentCapacity = newSize;
			return false;
		}

		return true;
	}

	public String generateGetter(String structName, String functionName) {
		StructDefinition def = getStructDefinition(structName);
		if (def == null)
			return "";

		StringBuilder sb = new StringBuilder();
		sb.append("/// Auto-generated by ShaderStructuredBuffer\n");

		if (isTextureBuffer) {
			int intsPerStruct = def.sizeBytes / 4; // assume tightly packed size in bytes
			int texelsPerStruct = (intsPerStruct + TEXEL_INT_COMPONENTS - 1) / TEXEL_INT_COMPONENTS;

			// sampler
			sb.append("uniform isamplerBuffer ")
				.append(structName)
				.append("Sampler;\n\n");

			sb.append(structName)
				.append(" ")
				.append(functionName)
				.append("(int index) {\n")
				.append("    ")
				.append(structName)
				.append(" s;\n")
				.append("    int base = index * ")
				.append(texelsPerStruct)
				.append(";\n\n");

			// fetch all required texels as ivec3 (use .rgb to be explicit)
			for (int t = 0; t < texelsPerStruct; t++) {
				sb.append("    ivec3 t").append(t).append(" = texelFetch(")
					.append(structName).append("Sampler, base + ").append(t).append(").rgb;\n");
			}
			sb.append("\n");

			// We'll emit direct accesses like tX.r / tX.g / tX.b for each component in order.
			int globalCompIndex = 0; // running index across all components of the struct

			for (Property prop : def.properties) {
				String glslType;
				switch (prop.type) {
					case Int:
						glslType = "int";
						break;
					case IVec2:
						glslType = "ivec2";
						break;
					case IVec3:
						glslType = "ivec3";
						break;
					case IVec4:
						glslType = "ivec4";
						break;
					case Float:
						glslType = "float";
						break;
					case FVec2:
						glslType = "vec2";
						break;
					case FVec3:
						glslType = "vec3";
						break;
					case FVec4:
						glslType = "vec4";
						break;
					case Mat3:
						glslType = "mat3";
						break;
					case Mat4:
						glslType = "mat4";
						break;
					default:
						glslType = "uint";
						break;
				}

				int components = prop.type.size / 4; // number of 32-bit components for the property

				sb.append("    // prop: ").append(prop.name).append(" (").append(glslType).append(")\n");

				if (prop.type == PropertyType.Float) {
					// single float stored as int bits
					sb.append("    s.").append(prop.name).append(" = intBitsToFloat(");
					buildComponentAccessor(sb, globalCompIndex++);
					sb.append(");\n");
				} else if (prop.type == PropertyType.Int) {
					sb.append("    s.").append(prop.name).append(" = ");
					buildComponentAccessor(sb, globalCompIndex++);
					sb.append(";\n");
				} else if (prop.type == PropertyType.IVec2 || prop.type == PropertyType.IVec3 || prop.type == PropertyType.IVec4) {
					sb.append("    s.").append(prop.name).append(" = ").append(glslType).append("(");
					for (int c = 0; c < components; c++) {
						if (c > 0) sb.append(", ");
						buildComponentAccessor(sb, globalCompIndex++);
					}
					sb.append(");\n");
				} else if (prop.type == PropertyType.FVec2 || prop.type == PropertyType.FVec3 || prop.type == PropertyType.FVec4) {
					// floats are stored as int bit patterns
					sb.append("    s.").append(prop.name).append(" = ").append(glslType).append("(");
					for (int c = 0; c < components; c++) {
						if (c > 0) sb.append(", ");
						sb.append("intBitsToFloat(");
						buildComponentAccessor(sb, globalCompIndex++);
						sb.append(")");
					}
					sb.append(");\n");
				} else if (prop.type == PropertyType.Mat3) {
					// mat3: 9 floats, column-major -> mat3(col0, col1, col2) where each col is vec3
					sb.append("    s.").append(prop.name).append(" = mat3(");
					for (int col = 0; col < 3; col++) {
						if (col > 0) sb.append(", ");
						sb.append("vec3(");
						for (int row = 0; row < 3; row++) {
							if (row > 0) sb.append(", ");
							sb.append("intBitsToFloat(");
							buildComponentAccessor(sb, globalCompIndex++);
							sb.append(") ");
						}
						sb.append(")");
					}
					sb.append(");\n");
				} else if (prop.type == PropertyType.Mat4) {
					// mat4: 16 floats, column-major -> 4 vec4 columns
					sb.append("    s.").append(prop.name).append(" = mat4(");
					for (int col = 0; col < 4; col++) {
						if (col > 0) sb.append(", ");
						sb.append("vec4(");
						for (int row = 0; row < 4; row++) {
							if (row > 0) sb.append(", ");
							sb.append("intBitsToFloat(");
							buildComponentAccessor(sb, globalCompIndex++);
							sb.append(") ");
						}
						sb.append(")");
					}
					sb.append(");\n");
				} else {
					// Fallback - treat as uint/int block
					sb.append("    // unsupported property type, copying raw ints as uints\n");
					sb.append("    s.").append(prop.name).append(" = ");
					buildComponentAccessor(sb, globalCompIndex++);
					sb.append(";\n");
				}

				sb.append("\n");
			}

			sb.append("    return s;\n");
			sb.append("}\n");
		} else {
			// SSBO path is unchanged from original -- simple std430 layout
			sb.append("layout(std430, binding = ")
				.append(binding.getBufferBindingIndex())
				.append(") buffer ")
				.append(structName)
				.append("Buffer { ")
				.append(structName)
				.append(" data[]; };\n\n");

			sb.append(structName)
				.append(" ")
				.append(functionName)
				.append("(int index) {\n")
				.append("    return data[index];\n")
				.append("}\n");
		}

		return sb.toString();
	}

	private int buildComponentAccessor(StringBuilder sb, int compIdx) {
		int texel = compIdx / TEXEL_INT_COMPONENTS;
		int channel = compIdx % TEXEL_INT_COMPONENTS;
		sb.append("t").append(texel).append('.');
		switch (channel) {
			case 0:
				sb.append('r');
				break;
			case 1:
				sb.append('g');
				break;
			default:
				sb.append('b');
				break;
		}
		return compIdx;
	}

	@Override
	public void destroy() {
		super.destroy();

		if (textureBufferId != 0)
			glDeleteTextures(textureBufferId);

		textureBufferId = 0;
		currentCapacity = 0;
	}
}
